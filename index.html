<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>OIIAGOLF - OIIA</title>
    <style>
        body {
            display: flex;
            flex-direction: column; 
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #333;
            font-family: sans-serif;
            overflow: auto;
        }
        #game-container {
            position: relative;
        }
        canvas {
            background-color: #2a8c4a;
            border: 4px solid #c2b280;
            cursor: pointer;
            display: block;
        }
        .cat-image {
            position: absolute;
            pointer-events: none;
            display: none;
        }
        h1 {
            color: yellow;
            margin-bottom: 15px;
        }
        #command-list {
            position: fixed;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 10px;
            border-radius: 8px;
            font-family: sans-serif;
            line-height: 1.5;
            border: 1px solid #fff;
            font-size: 12px;
        }
        #command-list h3 {
            margin: 0 0 8px 0;
            padding-bottom: 4px;
            border-bottom: 1px solid #fff;
            color: #ffdd00;
            font-size: 14px;
        }
        #command-list p {
            margin: 0;
        }
        #command-list span {
            font-size: 10px;
            color: #ccc;
        }
    </style>
</head>
<body>
    <h1>OIIAをひっぱってゴールにいれよう</h1>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <img id="staticCat" src="cat_static.png" class="cat-image" alt="静止猫">
        <img id="rotatingCat" src="cat_rotate.gif" class="cat-image" alt="回転猫">
    </div>

    <div id="command-list">
        <h3>ハードモードコマンド</h3>
        <p>hard1, hard2, hard3, hard4</p>
        <span>おなじコマンドでかいじょ</span>
    </div>
    
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        const staticCatImg = document.getElementById('staticCat');
        const rotatingCatImg = document.getElementById('rotatingCat');

        const meowSound = new Audio('cat_meow.mp3');
        meowSound.loop = true;
        const damageSound = new Audio('down.mp3');

        let lives = 5;
        let currentStage = 1;
        let isGameOver = false;
        let isInvincible = false; 

        let hard1Mode = false;
        let hard2Mode = false;
        let hard3Mode = false;
        let hard4Mode = false;
        let lastBgChangeTime = 0;

        let isTakingDamage = false;
        let fadeAlpha = 0;
        let fadeIn = true;

        const ball = {
            x: 100, y: 300, radius: 20, vx: 0, vy: 0,
        };

        const hole = { x: 700, y: 300, radius: 15, color: 'black' };

        const staticObstacles = [];
        const movingObstacles = [];
        const spikeObstacles = [];
        const ghostSpikes = [];
        const propeller = {
            x: 400, y: 300, angle: 0, speed: 0.005, armLength: 300, armWidth: 40
        };
        
        const friction = 0.985;
        let isDragging = false;
        let dragStart = { x: 0, y: 0 };

        function setCanvasSize(width, height) {
            canvas.width = width;
            canvas.height = height;
        }

        function loadStage(stageNum) {
            if (stageNum > 5) {
                isGameOver = true;
                setCanvasSize(800, 600);
                setTimeout(() => {
                    window.location.href = "https://www.youtube.com/watch?v=IxX_QHay02M&t=30s";
                }, 3000);
                return;
            }

            currentStage = stageNum;
            isInvincible = false;
            
            setCanvasSize(800, 600);
            ball.x = 100; ball.y = 300;
            hole.x = 700; hole.y = 300;
            ball.vx = 0; ball.vy = 0;

            staticObstacles.length = 0;
            movingObstacles.length = 0;
            spikeObstacles.length = 0;
            ghostSpikes.length = 0;
            
            const speedMultiplier = hard1Mode ? 2 : 1;

            switch (stageNum) {
                case 1:
                    generateStaticObstacles(5, 60, 120);
                    for (let i=0; i<3; i++) {
                        const size = 60 + Math.random() * 20;
                        movingObstacles.push({ x: 200 + i*180, y: 100 + Math.random()*200, width: size, height: size, vx: 0, vy: (1.5 + Math.random()) * 0.5, color: '#555' });
                    }
                    for (let i=0; i<3; i++) {
                        const size = 60 + Math.random() * 20;
                        movingObstacles.push({ x: 150 + Math.random()*200, y: 150 + i*150, width: size, height: size, vx: (1.5 + Math.random()) * 0.5, vy: 0, color: '#555' });
                    }
                    break;
                case 2:
                    generateStaticObstacles(3, 50, 100);
                    movingObstacles.push({ x: 250, y: 150, width: 150, height: 30, vx: 0, vy: 1, color: '#555' });
                    movingObstacles.push({ x: 500, y: 450, width: 150, height: 30, vx: 0, vy: -1, color: '#555' });
                    spikeObstacles.push({ x: 300, y: 300, size: 40, points: 8, color: 'red' });
                    spikeObstacles.push({ x: 500, y: 200, size: 40, points: 8, color: 'red' });
                    break;
                case 3:
                    ball.x = 50; ball.y = 300;
                    hole.x = 750; hole.y = 300;
                    const centerY = canvas.height / 2;
                    const range = (canvas.height / 2) * 1.3;
                    const minY = centerY - range / 2;
                    for (let i = 0; i < 5; i++) {
                        movingObstacles.push({
                            x: 150 + i * 120, y: minY + Math.random() * (range - 120),
                            width: 60, height: 120,
                            vx: 0, vy: ((2.5 + Math.random()) * 0.5) * speedMultiplier,
                            minY: minY, maxY: centerY + range / 2,
                            color: '#555'
                        });
                    }
                    break;
                case 4:
                    ball.x = 50; ball.y = 75;
                    hole.x = 750; hole.y = 525;
                    staticObstacles.push({ x: 0, y: 150, width: 650, height: 50, color: '#444' });
                    staticObstacles.push({ x: 150, y: 400, width: 650, height: 50, color: '#444' });
                    for(let i=0; i<7; i++) {
                        spikeObstacles.push({ 
                            x: 100 + Math.random() * 600, y: 200 + Math.random() * 200, 
                            size: 30, points: 8, color: 'purple',
                            vx: (Math.random() - 0.5) * 4,
                            vy: (Math.random() - 0.5) * 4
                        });
                    }
                    break;
                case 5:
                    ball.x = 50; ball.y = 300;
                    hole.x = 750; hole.y = 300;
                    propeller.angle = 0;
                    for(let i=0; i<4; i++) {
                        spikeObstacles.push({ 
                            x: 100 + Math.random() * 600, y: 100 + Math.random() * 400, 
                            size: 35, points: 8, color: 'purple',
                            vx: (Math.random() - 0.5) * 3,
                            vy: (Math.random() - 0.5) * 3
                        });
                    }
                    break;
            }

            if (hard1Mode) {
                for(let i=0; i<6; i++) {
                    spikeObstacles.push({ 
                        x: 100 + Math.random() * (canvas.width - 200), 
                        y: 100 + Math.random() * (canvas.height - 200), 
                        size: 30, points: 8, color: 'purple',
                        vx: (Math.random() - 0.5) * 4,
                        vy: (Math.random() - 0.5) * 4
                    });
                }
            }
            if (hard2Mode) {
                for(let i=0; i<8; i++) {
                    ghostSpikes.push({
                        x: 100 + Math.random() * (canvas.width - 200), 
                        y: 100 + Math.random() * (canvas.height - 200), 
                        size: 40, points: 6, color: 'rgba(200, 200, 255, 0.5)',
                        vx: (Math.random() - 0.5) * 12,
                        vy: (Math.random() - 0.5) * 12
                    });
                }
            }
        }

        function takeDamage() {
            if (isTakingDamage || isInvincible) return; 
            lives--;
            isTakingDamage = true;
            isInvincible = true;
            fadeIn = true;
            fadeAlpha = 0;
            meowSound.pause();
            damageSound.currentTime = 0;
            damageSound.play();
        }
        
        function checkCollision(obj1, obj2) {
            if (obj1.radius && obj2.width) {
                let closestX = Math.max(obj2.x, Math.min(obj1.x, obj2.x + obj2.width));
                let closestY = Math.max(obj2.y, Math.min(obj1.y, obj2.y + obj2.height));
                let dX = obj1.x - closestX;
                let dY = obj1.y - closestY;
                return (dX * dX + dY * dY) < (obj1.radius * obj1.radius);
            } else if (obj1.width && obj1.height && obj2.width && obj2.height) {
                 return obj1.x < obj2.x + obj2.width && obj1.x + obj1.width > obj2.x && obj1.y < obj2.y + obj2.height && obj1.y + obj1.height > obj2.y;
            }
            return false;
        }

        function generateStaticObstacles(num, minSize, maxSize) {
            const safeZonePadding = 100;
            const ballSafeRect = { x: ball.x - safeZonePadding, y: ball.y - safeZonePadding, width: safeZonePadding*2, height: safeZonePadding*2 };
            const holeSafeRect = { x: hole.x - safeZonePadding, y: hole.y - safeZonePadding, width: safeZonePadding*2, height: safeZonePadding*2 };
            for (let i = 0; i < num; i++) {
                let newObstacle, validPosition = false, attempts = 0;
                while (!validPosition && attempts < 100) {
                    const width = minSize + Math.random() * (maxSize - minSize);
                    const height = minSize + Math.random() * (maxSize - minSize);
                    const x = Math.random() * (canvas.width - width);
                    const y = Math.random() * (canvas.height - height);
                    newObstacle = { x, y, width, height, color: '#444' };
                    if (checkCollision(newObstacle, ballSafeRect) || checkCollision(newObstacle, holeSafeRect)) {
                        attempts++; continue;
                    }
                    let overlapsWithOthers = false;
                    for (const existing of staticObstacles) { if (checkCollision(newObstacle, existing)) { overlapsWithOthers = true; break; } }
                    if (overlapsWithOthers) { attempts++; continue; }
                    validPosition = true;
                }
                if (validPosition) staticObstacles.push(newObstacle);
            }
        }

        canvas.addEventListener('mousedown', (e) => {
            if (isGameOver || isTakingDamage) return;
            const mousePos = getMousePos(e);
            if (Math.hypot(mousePos.x - ball.x, mousePos.y - ball.y) < ball.radius) {
                isDragging = true;
                dragStart.x = mousePos.x;
                dragStart.y = mousePos.y;
                ball.vx = 0;
                ball.vy = 0;
                meowSound.playbackRate = 1.0;
                meowSound.currentTime = 0;
                meowSound.play();
            }
        });
        
        window.addEventListener('mouseup', (e) => {
            if (!isDragging) return;
            isDragging = false;
            isInvincible = false;
            const mousePos = getMousePos(e);
            ball.vx = (dragStart.x - mousePos.x) * 0.15;
            ball.vy = (dragStart.y - mousePos.y) * 0.15;
            if (Math.hypot(ball.vx, ball.vy) < 0.1) {
                meowSound.pause();
            }
        });
        
        function update() {
            if (isGameOver) return;
            if (isTakingDamage) {
                if (fadeIn) {
                    if ((fadeAlpha += 0.05) >= 1) {
                        fadeAlpha = 1; 
                        setTimeout(() => { fadeIn = false; }, 1000);
                    }
                } else {
                    if ((fadeAlpha -= 0.05) <= 0) {
                        fadeAlpha = 0; 
                        isTakingDamage = false;
                        loadStage(currentStage);
                    }
                }
                return;
            }

            if (!isDragging) {
                const speed = Math.hypot(ball.vx, ball.vy);
                if (speed > 0.05) {
                    ball.vx *= friction;
                    ball.vy *= friction;
                } else {
                    ball.vx = 0;
                    ball.vy = 0;
                    meowSound.pause();
                }

                if(hard3Mode) {
                    ball.vy += 0.002;
                }

                ball.x += ball.vx;
                ball.y += ball.vy;
            }

            if (ball.x < ball.radius) { ball.x = ball.radius; ball.vx *= -1; }
            if (ball.x > canvas.width - ball.radius) { ball.x = canvas.width - ball.radius; ball.vx *= -1; }
            if (ball.y < ball.radius) { ball.y = ball.radius; ball.vy *= -1; }
            if (ball.y > canvas.height - ball.radius) { ball.y = canvas.height - ball.radius; ball.vy *= -1; }

            for (const obstacle of [...staticObstacles, ...movingObstacles]) {
                if (checkCollision(ball, obstacle)) {
                    const overlapX = ball.x - (obstacle.x + obstacle.width / 2);
                    const overlapY = ball.y - (obstacle.y + obstacle.height / 2);
                    const combinedHalfWidths = ball.radius + obstacle.width / 2;
                    const combinedHalfHeights = ball.radius + obstacle.height / 2;
                    if (Math.abs(overlapX) / combinedHalfWidths > Math.abs(overlapY) / combinedHalfHeights) {
                        ball.vx *= -1.05;
                        ball.x = (overlapX > 0) ? obstacle.x + obstacle.width + ball.radius : obstacle.x - ball.radius;
                    } else {
                        ball.vy *= -1.05;
                        ball.y = (overlapY > 0) ? obstacle.y + obstacle.height + ball.radius : obstacle.y - ball.radius;
                    }
                }
            }
            
            for (const obstacle of movingObstacles) {
                obstacle.x += obstacle.vx;
                obstacle.y += obstacle.vy;
                if (obstacle.minY !== undefined && obstacle.maxY !== undefined) {
                    if (obstacle.y < obstacle.minY || obstacle.y + obstacle.height > obstacle.maxY) {
                        obstacle.vy *= -1;
                    }
                } else {
                    if (obstacle.x < 0 || obstacle.x + obstacle.width > canvas.width) {
                        obstacle.vx *= -1;
                    }
                    if (obstacle.y < 0 || obstacle.y + obstacle.height > canvas.height) {
                        obstacle.vy *= -1;
                    }
                }
            }

            for (const spike of [...spikeObstacles, ...ghostSpikes]) {
                if(spike.vx !== undefined && spike.vy !== undefined) {
                    spike.x += spike.vx;
                    spike.y += spike.vy;
                    if (spike.x - spike.size / 2 < 0 || spike.x + spike.size / 2 > canvas.width) spike.vx *= -1;
                    if (spike.y - spike.size / 2 < 0 || spike.y + spike.size / 2 > canvas.height) spike.vy *= -1;
                }
            }

            for (const spike of spikeObstacles) {
                if (Math.hypot(ball.x - spike.x, ball.y - spike.y) < ball.radius + spike.size / 2) takeDamage();
            }
            if (currentStage === 3) {
                if (ball.y < 200 + ball.radius || ball.y > 400 - ball.radius) takeDamage();
            }

            if (currentStage === 5) {
                propeller.angle += propeller.speed * (hard1Mode ? 2 : 1);
                for (let i = 0; i < 4; i++) {
                    const armAngle = propeller.angle + (Math.PI / 2) * i;
                    if (checkRotatedRectCollision(ball, propeller, armAngle)) {
                        if (i === 0 || i === 2) {
                           takeDamage();
                        } else {
                            ball.vx *= -1.1; ball.vy *= -1.1;
                        }
                    }
                }
            }

            if (Math.hypot(ball.x - hole.x, ball.y - hole.y) < hole.radius && Math.hypot(ball.vx, ball.vy) < 4) {
                loadStage(currentStage + 1);
            }
        }
        
        function checkRotatedRectCollision(circle, rect, angle) {
            const rectX = rect.x;
            const rectY = rect.y;
            const circleX = circle.x - rectX;
            const circleY = circle.y - rectY;
            const rotatedX = circleX * Math.cos(-angle) - circleY * Math.sin(-angle);
            const rotatedY = circleX * Math.sin(-angle) + circleY * Math.cos(-angle);
            const armRect = {
                x: 0,
                y: -rect.armWidth / 2,
                width: rect.armLength,
                height: rect.armWidth
            };
            let closestX = Math.max(armRect.x, Math.min(rotatedX, armRect.x + armRect.width));
            let closestY = Math.max(armRect.y, Math.min(rotatedY, armRect.y + armRect.height));
            let dX = rotatedX - closestX;
            let dY = rotatedY - closestY;
            return (dX * dX + dY * dY) < (circle.radius * circle.radius);
        }

        function draw() {
            if (hard4Mode) {
                const now = Date.now();
                if (now - lastBgChangeTime > 100) {
                    const r = Math.floor(Math.random() * 256);
                    const g = Math.floor(Math.random() * 256);
                    const b = Math.floor(Math.random() * 256);
                    canvas.style.backgroundColor = `rgb(${r},${g},${b})`;
                    lastBgChangeTime = now;
                }
            } else {
                canvas.style.backgroundColor = '#2a8c4a';
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (isGameOver) {
                ctx.fillStyle = 'black'; ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'cyan'; ctx.font = '80px Arial'; ctx.textAlign = 'center';
                ctx.fillText('GAME CLEAR!', canvas.width / 2, canvas.height / 2 - 50);
                const iconSize = 100;
                ctx.globalAlpha = 0.8;
                ctx.drawImage(staticCatImg, canvas.width / 2 - iconSize / 2 - 80, canvas.height / 2 + 40, iconSize, iconSize);
                ctx.globalAlpha = 1;
                ctx.fillStyle = 'white'; ctx.font = '100px Arial'; ctx.textAlign = 'left';
                ctx.fillText(`× ${lives}`, canvas.width / 2 - 30, canvas.height / 2 + 125);
                return;
            }

            if (isTakingDamage) {
                ctx.fillStyle = `rgba(0, 0, 0, ${fadeAlpha})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                if (fadeAlpha >= 1) {
                    const iconSize = 100;
                    ctx.drawImage(staticCatImg, canvas.width / 2 - iconSize / 2 - 60, canvas.height / 2 - iconSize/2, iconSize, iconSize);
                    ctx.fillStyle = 'white'; ctx.font = '100px Arial'; ctx.textAlign = 'left';
                    ctx.fillText(`× ${lives}`, canvas.width / 2 - 10, canvas.height / 2 + 35);
                }
                updateCatImage();
                return;
            }

            if (currentStage === 3 && !hard4Mode) {
                const courseTop = 200;
                const courseBottom = 400;
                ctx.fillStyle = '#1a5930';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = "#2a8c4a";
                ctx.fillRect(0, courseTop, canvas.width, courseBottom - courseTop);
                if (Math.floor(Date.now() / 150) % 2 === 0) {
                    ctx.fillStyle = 'yellow';
                } else {
                    ctx.fillStyle = 'orange';
                }
                ctx.fillRect(0, courseTop - 5, canvas.width, 5);
                ctx.fillRect(0, courseBottom, canvas.width, 5);
            }

            ctx.fillStyle = hole.color; ctx.beginPath(); ctx.arc(hole.x, hole.y, hole.radius, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = 'white'; ctx.font = '20px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'bottom';
            ctx.fillText('ゴール', hole.x, hole.y - hole.radius - 5);
            
            for (const obstacle of [...staticObstacles, ...movingObstacles]) {
                ctx.fillStyle = obstacle.color;
                ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
            }
            for (const spike of [...spikeObstacles, ...ghostSpikes]) {
                ctx.save();
                ctx.translate(spike.x, spike.y);
                ctx.fillStyle = Math.floor(Date.now() / 150) % 2 === 0 ? spike.color : 'darkred';
                ctx.beginPath();
                for(let i = 0; i < spike.points * 2; i++){
                    const angle = Math.PI * 2 / (spike.points * 2) * i;
                    const radius = (i % 2 === 0) ? spike.size : spike.size / 2;
                    ctx.lineTo(radius * Math.cos(angle), radius * Math.sin(angle));
                }
                ctx.closePath(); ctx.fill();
                ctx.restore();
            }
            if (currentStage === 5) {
                ctx.save();
                ctx.translate(propeller.x, propeller.y);
                ctx.rotate(propeller.angle);
                for (let i = 0; i < 4; i++) {
                    ctx.save();
                    ctx.rotate((Math.PI / 2) * i);
                    if (i === 0 || i === 2) {
                        ctx.fillStyle = Math.floor(Date.now() / 150) % 2 === 0 ? 'purple' : 'darkred';
                    } else {
                        ctx.fillStyle = '#555';
                    }
                    ctx.fillRect(0, -propeller.armWidth / 2, propeller.armLength, propeller.armWidth);
                    ctx.restore();
                }
                ctx.restore();
            }

            updateCatImage();
            
            if (isDragging) {
                const mousePos = getMousePos();
                const dx = ball.x - mousePos.x;
                const dy = ball.y - mousePos.y;
                const angle = Math.atan2(dy, dx);
                const length = Math.min(Math.hypot(dx, dy), 150);
                ctx.save();
                ctx.translate(ball.x, ball.y);
                ctx.rotate(angle);
                ctx.strokeStyle = '#FF0000';
                ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(length, 0);
                ctx.stroke();
                const arrowHeadSize = 15;
                ctx.fillStyle = '#FF0000';
                ctx.beginPath();
                ctx.moveTo(length, 0);
                ctx.lineTo(length - arrowHeadSize, -arrowHeadSize / 2);
                ctx.lineTo(length - arrowHeadSize, arrowHeadSize / 2);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }

            ctx.drawImage(staticCatImg, 20, 15, 30, 30);
            ctx.textAlign = 'left'; ctx.textBaseline = 'alphabetic'; ctx.fillStyle = 'white'; ctx.font = '30px Arial';
            ctx.fillText(`× ${lives}`, 60, 40);
        }

        function updateCatImage() {
            if (isTakingDamage || isGameOver) {
                staticCatImg.style.display = 'none';
                rotatingCatImg.style.display = 'none';
                return;
            }
            const speed = Math.hypot(ball.vx, ball.vy);
            const isMoving = isDragging || speed > 0.05;
            const catToShow = isMoving ? rotatingCatImg : staticCatImg;
            const catToHide = isMoving ? staticCatImg : rotatingCatImg;

            catToShow.style.display = 'block';
            catToHide.style.display = 'none';

            catToShow.style.width = `${ball.radius * 2}px`;
            catToShow.style.height = `${ball.radius * 2}px`;
            catToShow.style.left = `${ball.x - ball.radius}px`;
            catToShow.style.top = `${ball.y - ball.radius}px`;
            catToShow.style.opacity = isInvincible ? Math.abs(Math.sin(Date.now() / 100)) : 1;
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        let currentEvent;
        window.addEventListener('mousemove', e => { currentEvent = e; });
        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            const event = e || currentEvent; 
            if (!event) return { x: 0, y: 0 };
            return { x: event.clientX - rect.left, y: event.clientY - rect.top };
        }
        
        let keySequence = '';
        const commands = {
            'skipiia': () => loadStage(currentStage + 1), // ★修正
            'oiia': () => { window.location.href = "https://www.youtube.com/watch?v=dQw4w9WgXcQ"; }, // ★追加
            'cat': () => { window.location.href = "https://www.youtube.com/watch?v=ycHVUvvOwzY"; }, // ★追加
            'hard1': () => { hard1Mode = !hard1Mode; loadStage(currentStage); },
            'hard2': () => { hard2Mode = !hard2Mode; loadStage(currentStage); },
            'hard3': () => { hard3Mode = !hard3Mode; loadStage(currentStage); },
            'hard4': () => { hard4Mode = !hard4Mode; loadStage(currentStage); }
        };

        window.addEventListener('keydown', (e) => {
            if(isGameOver || isTakingDamage) return;
            keySequence += e.key.toLowerCase();
            
            // 最長のコマンドは skipiia (7文字) なので、それより長く保持
            if(keySequence.length > 7) { 
                keySequence = keySequence.slice(-7);
            }

            for (const code in commands) {
                if(keySequence.endsWith(code)) {
                    commands[code]();
                    keySequence = ''; // コマンド実行後はシーケンスをリセット
                    return;
                }
            }
        });

        let loadedImages = 0;
        const totalImages = 2;
        const startGame = () => {
            loadedImages++;
            if (loadedImages === totalImages) {
                loadStage(1);
                gameLoop();
            }
        };
        staticCatImg.onload = startGame;
        rotatingCatImg.onload = startGame;
        
        staticCatImg.onerror = () => document.body.innerHTML = "<h1>エラー: cat_static.png が見つかりません</h1>";
        rotatingCatImg.onerror = () => document.body.innerHTML = "<h1>エラー: cat_rotate.gif が見つかりません</h1>";
    </script>
</body>
</html>
